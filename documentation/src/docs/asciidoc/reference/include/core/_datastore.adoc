[[Datastore]]
=== Datastore

The link:{apidir}/com/holonplatform/core/datastore/Datastore.html[Datastore^] API is the main entry point to manage data access and persistence in a technology/platform/vendor independent way.

The `Datastore` data management strategy relies on the Holon platform <<Property, property model>> architecture to represent and manage data model attributes in a generic and implementation-independent way, using the  <<PropertyBox>> structure as data interchange carrier between the `Datastore` API and the concrete data model.

A concrete `Datastore` implementation could provide a more specialized API, with functionalities expressly related to the specific persistence technology/model.

We'll refer to an _entity_ in this documentation as a generic persistence model data container. An _entity_ may be for example a _table_ in a RDBMS context, a _JPA entity class_ in a JPA environment or a _document_ in a document based data store.

The `Datastore` API provides the following operations:

* *Refresh:* Refresh the data of a data model _entity_, retrieving the most updated version.
* *Insert:* Insert a new data model _entity_ into the persistence store.
* *Update:* Update a data model _entity_ already present in the persistence store.
* *Save:* Insert or update a data model _entity_, depending on the existence of the _entity_ itself in the persistence store.
* *Bulk* operations definition and execution (`bulkInsert`, `bulkUpdate` and `bulkDelete`): to execute batch operations in the persistence store.
* *Query definition and execution*: to configure and execute _queries_ against the persistence store, allowing to declare query results restrictions, aggregations and sorting and to obtain the query results using different _projections_.

Each operation which involves a possible persistence store data modification returns an `OperationResult` type object, which provides information about the operation outcome, such as the number of the elements affected by the execution of the operation or the _auto-generated_ key values, if the concrete persistence store supports this feature.

[[ExpressionResolver]]
==== Expressions and resolvers

The `Datastore` API architecture is designed on top of the Holon platform link:{apidir}/com/holonplatform/core/Expression.html[Expression^] based architecture.

An `Expression` is a very abstract and generic representation of an element of a language. The `Datastore` API uses _expressions_ to "translate" a meta-language into the actual language which can be understood by the concrete persistense context engine to which the `Datastore` is bound. 

The link:{apidir}/com/holonplatform/core/ExpressionResolver.html[ExpressionResolver^] interface is the key element to perform the language manipulation and translation, since it is used to _resolve_ an `Expression` type into another `Expression` type.

An `ExpressionResolver` declares the expression type which is able to process, and the expression type which provides as resolution result. An `ExpressionResolver` can return an empty `Optional` if it is not able to resolve given expression: this way, the resultion process must proceed to the next available resolver for given expression and resolution type.

A generic `ResolutionContext` object is provided to the `ExpressionResolver` resolution method, to provide information about the current resolution context.

A set of `ExpressionResolver` can be handled using an link:{apidir}/com/holonplatform/core/ExpressionResolverRegistry.html[ExpressionResolverRegistry^]. When an `Expression` must be resolved, all the available resolvers which declare to resolve the given expression type and provide a consistent resolution type will be taken into account. These resolvers are invoked sequentially, 
returning the first valid resolved expression, if any.

To order the expression resolvers with the same expression types, the `javax.annotation.Priority` annotation can be used on the `ExpressionResolver` implementation class to assign a priority order, where lower values corresponds to higher priority.

The `Datastore` API , extending the `ExpressionResolverSupport` interface, supports the registration of new `ExpressionResolver` instances. This is the recommended way to implement `Datastore` *extensions* and persistence operations *customization*.

Since a `Datastore` implementation can be bound to very different data models and persistence context, each expression resolution strategy is highly dependent from the concrete `Datastore` implementation, including a possibly specialized version of the `ResolutionContext`. See each concrete `Datastore` implementation documentation to learn about the `ExpressionResolver` support and the available expression types which can be used for extensibility purposes.

Anyway, the core meta-language expressions set is common to any `Datastore` implementation. For this reason, it is possible to provide `Datastore` API extensions in a general and implementation independent way using the `ExpressionResolver` based strategy when the expression resolution is bound to the standard meta-language expressions.

Most of the standard `Datastore` operations (for example the <<Query>> operation) support `ExpressionResolver` registration, to provide expression resolution manipulation only for a specific operation execution. 

See the <<DatastoreExtension>> section for details.

==== Property data types

The `Datastore` API fully supports *property values conversions* using the standard <<PropertyValueConverter,property value converter>> API. If a `Property` declares a value converter, it will be used to perform conversions from the property type to the data model attribute type and back. 

A converter can be used to adapt specific data types, to use custom types or to face common value conversion needs, such as _enumeration_ property types mapped to integer or text data model types.

The Holon platform `Datastore` fully supports the new *Java 8 Date and Time API*, which represents a big step forward compared to the previous date and time support classes, to address the shortcomings of the older `java.util.Date` and `java.util.Calendar` types. It is strongly recommended to use the new `java.time.*` types for date and time properties, such as `LocalDate`, `LocalTime`, and `LocalDateTime`.

When a `java.util.Date` or `java.util.Calendar` property type is used with `Datastore` API operations, it is recommended to configure the actual *temporal type* which is expected for the property, to ensure data consistency. This can be done through the <<PropertyConfiguration,property configuration>>.

[[DataTarget]]
==== DataTarget

The link:{apidir}/com/holonplatform/core/datastore/DataTarget.html[DataTarget^] interface is used by the `Datastore` API and the <<Query,Query definition API>> to refer to an _entity_ of the persistence model in an abstract and independent way from the concrete persistence layer. 

From the `DataTarget` point of view, an _entity_ has the meaning of a _collection of data model attributes_, and it is represented by a link:{apidir}/com/holonplatform/core/Path.html[Path^], i.e. by a symbolic *name*.

Examples of `DataTarget` representations are:

* The name of a _table_ in a RDBMS.
* The class of a JPA _entity_.
* The document _collection_ name in a document-oriented database.

Concrete `Datastore` implementations could provide more specialized `DataTarget` object types to identify a data model _entity_ which is specific of the persistence model to which the `Datastore` is bound.

The `DataTarget` interface provides static methods to create data targets using the default *name*  representation, optionally providing the `DataTarget` (`Path`) type:

[source, java]
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleDatastore.java[tag=datatarget,indent=0]
----
<1> Create a default `String` type `DataTarget` named `test1`
<2> Create a `MyType` type `DataTarget` named `test2`

All the `Datastore` operations definition APIs involving persistent _entity_ structures use a `DataTarget` to identify the data model _entity_ to which the operation refers.

[[DataManipulationOperations]]
==== Data manipulation operations

The link:{apidir}/com/holonplatform/core/datastore/Datastore.html[Datastore^] API provides the most common data manipulation operations, listed in the table below.

Each operation throws a link:{apidir}/com/holonplatform/core/exceptions/DataAccessException.html[DataAccessException^] if an error occurs during the operation execution.

Each operation (except for _refresh_) support configurable write *options*, represented by the `WriteOption` marker interface. Tipically, write options are specific of the underlying persistence model and each concrete `Datastore` implementation provides a set of suitable write options. See each specific `Datastore`  documentation for further information.

The link:{apidir}/com/holonplatform/core/datastore/DefaultWriteOption.html[DefaultWriteOption^] enumeration provides write options which can be available for any `Datastore` API. By now, a single default write option is defined:

*BRING_BACK_GENERATED_IDS*: Bring back any auto-generated id value into the `PropertyBox` which was subject of a data manipulation operation, if a corresponding `Property` (using the property name) is available in the `PropertyBox` property set. 

NOTE: Check specific `Datastore` implementations documentation to learn if this option is actually supported.

|===
|Operation |Purpose |Return

|`*refresh*(DataTarget target, PropertyBox propertyBox)`
|*Refresh* the values of the properties of given `PropertyBox`, reloading them from the persistence store, using given *data target* to identify the persistence model _entity_.
|The refreshed `PropertyBox`

|`*insert*(DataTarget target, PropertyBox propertyBox, WriteOption... options)`
|*Insert* a new data model _entity_, identified by given *data target* and represented by given `PropertyBox`, into the persistence store.
|The `OperationResult`. If one or more data model attribute was auto-generated by the concrete persistence store, such values are returned by the `getInsertedKeys` method.

|`*update*(DataTarget target, PropertyBox propertyBox, WriteOption... options)`
|*Update* an existing data model _entity_, identified by given *data target* and represented by given `PropertyBox`, in the persistence store.
|The `OperationResult`. 

|`*save*(DataTarget target, PropertyBox propertyBox, WriteOption... options)`
|Insert a new data model _entity_ (identified by given *data target* and represented by given `PropertyBox`) into the persistence store if the _entity_ does not exists, or update it if the _entity_ is already present in the persistence store.
|The `OperationResult`. 

|`*delete*(DataTarget target, PropertyBox propertyBox, WriteOption... options)`
|*Remove* a data model _entity_, identified by given *data target* and represented by given `PropertyBox`, from the persistence store.
|The `OperationResult`. 

|`bulkInsert(DataTarget target, PropertySet<?> propertySet, WriteOption... options)`
|Configure and perform a _bulk_ *insert* of data model _entities_ identified by given *data target* and represented by `PropertyBox` instances. Only the properties contained in the given `PropertySet` will be taken into account to perform the insert operations.
|The `BulkInsert` API to configure and perform the bulk operation. 

|`bulkUpdate(DataTarget target, WriteOption... options)`
|Configure and perform a _bulk_ *update* of data model _entities_ identified by given *data target*, to change a set of property values according to a set of restriction predicates to identify the set of data model _entities_ to update.
|The `BulkUpdate` API to configure and perform the bulk operation.

|`bulkDelete(DataTarget target, WriteOption... options)`
|Configure and perform a _bulk_ *delete* of data model _entities_ identified by given *data target*, providing a set of restriction predicates to identify the set of data model _entities_ to remove.
|The `BulkDelete` API to configure and perform the bulk operation.
|===

[source, java]
.Data manipulation operations examples
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleDatastore.java[tag=datastore,indent=0]
----
<1> Save the `PropertyBox` containing given property value using the specified `DataTarget` (insert a new _entity_ if not present in the persistence store or update it if exists)
<2> Insert the given `PropertyBox` data into the persistence store using the specified `DataTarget`
<3> Update the given `PropertyBox` data into the persistence store using the specified `DataTarget`
<4> Refresh the `PropertyBox` property values using the specified `DataTarget`
<5> Remove the _entity_ which corresponds to given `PropertyBox`
<6> Execute a _bulk_ insert operation using the specified `DataTarget`, inserting given `PropertyBox` elements
<7> Execute a _bulk_ update operation using the specified `DataTarget`, setting the property value to `updated` when the property value is `null`
<8> Execute a _bulk_ delete operation using the specified `DataTarget`, removing entities for which the given property value is `null`

[[Query]]
=== Query

The link:{apidir}/com/holonplatform/core/query/Query.html[Query^] API can be used to configure and execute _queries_ against the persistence data store.

Just like any other `Datastore` API operation, the `Query` API relies on the Holon platform <<Property,property model>> to represent the data model attributes and to obtain the query results, using a <<PropertyBox,PropertyBox>> to provide a set of property values.

This allows the query to be declared and executed in an abstract and implementation-independent way.

The `Query` API supports the following clauses and configuration attributes:

* The <<DataTarget>> on which the query has to be performed.
* A set of query *restrictions*, expressed as <<QueryFilter>> clauses.
* The query results *sorting* declarations, expressed as <<QuerySort>> clauses.
* The query results *aggregation*, expressed as <<QueryAggregation>> clauses.
* The query results *paging*, to configure the query result set _limit_ and _offset_.
* A set of generic query configuration *parameters*.

The query clauses which involve the reference to data model attributes (filtering, sorting, aggregation) are expressed using the <<Property>> abstraction.

[[QueryDefinition]]
==== Query definition

A `Query` instance is obtained using the the Datastore `query()` method.

The `Query` interface provides methods to configure and define the query configuration and clauses, using a fluent builder pattern. The query configuration setting and clauses definitions are described below.

[[QueryFilter]]
===== QueryFilter

The link:{apidir}/com/holonplatform/core/query/QueryFilter.html[QueryFilter^] interface represents a query results restriction.

Most common restriction predicates representations are provided by the core platform classes. The following predicates are available:

* *Is null / is not null:* The value of a property is _null_ / not _null_
* *equal / not equal:* The value of a property is equal / not equal to a given value
* *less than / less than or equal:* The value of a property is less than / less than or equal to a given value
* *greater than / greater than or equal:* The value of a property is greater than / greater than or equal to a given value
* *between:* The value of a property is included between a minimum and a maximum value
* *in / not in:* The value of a property is present / not present in a set of values
* *contains:* The value of a `String` property contains given text, ignoring case or not
* *startsWirth:* The value of a `String` property contains starts with text, ignoring case or not
* *endsWith:* The value of a `String` property contains ends with text, ignoring case or not

Negation, conjunction and disjunction of predicates:

* *not:* Negation of a predicate
* *and:* Conjunction of predicates (represents the `AND` logical operation)
* *or:* Disjunction of predicates (represents the `OR` logical operation)

The `QueryFilter` predicates can be obtained in two ways:

*1.* Using the static methods provided by the `QueryFilter` interface, specifying the <<Property>> the predicate refers to when required.

[source, java]
.Examples using QueryFilter
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=filter1,indent=0]
----

*2.* For <<Property>> related predicates, using directly the static methods provided by the `Property` interface.

TIP: `QueryFilter` s can be added to a `Query` using the `filter(QueryFilter filter)` query builder method, which adds a filter predicate to the query. If a `QueryFilter` has already been associated to the query, the new filter is added to the query in conjunction with the existing predicates, i.e. using a `AND` logical operation.

[source, java]
.Examples using Property
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=filter2,indent=0]
----

[[QuerySort]]
===== QuerySort

The link:{apidir}/com/holonplatform/core/query/QuerySort.html[QuerySort^] interface represents a query results sorting directive, referred to a <<Property>>.

The `SortDirection` enumeration is used to declare the sort direction (ascending or descending).

A list of `QuerySort` can be composed to create a sort declaration which involves more than one `Property`, for each declaring the sort direction.

The `QuerySort` directives can be obtained in two ways:

*1.* Using the static methods provided by the `QuerySort` interface, specifying the <<Property>> to which the sort refers.

[source, java]
.Examples using QuerySort
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=sort1,indent=0]
----

*2.* Using directly the static methods provided by the `Property` interface.

[source, java]
.Examples using Property
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=sort2,indent=0]
----

TIP: `QuerySort` can be added to a `Query` using the `sort(QuerySort sort)` query builder method, which adds a sort declaration to the query. If one or more `QuerySort` has already been associated to the query, the new sort is added at the end of the query sorts list.

[[QueryAggregation]]
===== Aggregations

*Aggregation clause:*

A `Query` supports a results aggregation clause, represented by the link:{apidir}/com/holonplatform/core/query/QueryAggregation.html[QueryAggregation^] interface. This interface provides a fluent builder to create aggregation clauses.

The aggregation clause can be used to specify:

* Which `Path`s must be used to aggregate the query results, i.e. *grouping the results* by the values of the specified paths;
* The *optional restrictions* to apply on the aggregation path values, expressed by using standard `QueryFilter` predicates.

WARNING: Query results aggregation semantics can be slightly different from one Datastore implementation to another. Each Datastore implementation should ensure a consistent query execution behaviour, but in some situations it may not be possible to perform the aggregation operation for some query configurations. For example, many RDBMS engines do not allow to project a query result which is not part of the query aggregation clause unless an aggregation function is used.

[source, java]
.Examples of aggregation
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=aggregation,indent=0]
----
<1> Aggregate the results grouping by `PROPERTY`
<2> Aggregate the results grouping by `PROPERTY` and restrict the aggregation property values to not _null_ values

*Aggregation functions:*

A set of basic results aggregation _functions_ are provided by the default `Datastore`. An aggregation function is related to a `Path` and allows to aggregate the query results related to such path with a specific aggregation semantic.

A Datastore *function* is represented by the {apidir}/com/holonplatform/core/query/QueryFunction.html[QueryFunction^] interface and the following builtin aggregation functions are provided:

* {apidir}/com/holonplatform/core/query/QueryFunction.Count.html[Count^] : counts the results
* {apidir}/com/holonplatform/core/query/QueryFunction.Min.html[Min^] : return the smallest value
* {apidir}/com/holonplatform/core/query/QueryFunction.Max.html[Max^] : return the larger value
* {apidir}/com/holonplatform/core/query/QueryFunction.Avg.html[Avg^] : return the average value
* {apidir}/com/holonplatform/core/query/QueryFunction.Sum.html[Sum^] : return the sum of the values

An aggregation function can be used as a query projection or expression, and can be created in two ways:

*1.* Using the static methods provided by the `FunctionExpression` interface, by specifying the `Path` to apply the function to.
*2.* Using directly the static methods provided by the `PathProperty` interface.

[source, java]
.Examples of aggregation functions
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=aggfun,indent=0]
----

===== Paging results

`Query` supports results *pagination*, allowing to set:

* *limit:*: results limit, i.e. the max number of results to provide
* *offset:*: 0-based offset from which to fetch the query results within the total results set

[source, java]
.Pagination example
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=pagination,indent=0]
----
<1> Limit the query results to `100` and fetch the results starting from `0` (i.e. fetch the first page where a page is a window of 100 results)
<2> Limit the query results to `100` and fetch the results starting from `100` (i.e. fetch the second page where a page is a window of 100 results)

===== Query results projection

`Query` results are obtained using a _projection_, represented by the link:{apidir}/com/holonplatform/core/query/QueryProjection.html[QueryProjection^] interface.

The `Query` interface extends the link:{apidir}/com/holonplatform/core/query/QueryResults.html[QueryResults^] interface, which provides methods to execute the query and obtain the query results.

Two main methods are provided to obtain the query results:

* `stream(QueryProjection<R> projection)`: Obtain the query results as a `Stream`, using given projection to define the type of the objects contained in the stream
* `count()`: Count the results of the query

Two additional convenience methods are made available by the `QueryResults` interface:

* `findOne(QueryProjection<R> projection)`: Get a single expected result from the query, which type matches the projection type. If more than one result is obtained from query execution, a `QueryNonUniqueResultException` is thrown
* `list(QueryProjection<R> projection)`: Convenience method to obtain query results `Stream` as a `List`

*Builtin projections:*

The platform provides the following query projections:

* `PathProperty` and `AggregationProperty` are query projections, mapping the result type into the property type
* `PropertySetProjection` uses a set of `Property` to map the query results into `PropertyBox` objects containing the values of the properties of the set returned by the query execution.

The `QueryResults` interface provides convenience methods helpful to use the `PropertySetProjection` query projection:

* `stream(Iterable<P> properties)` and `stream(Property... properties)`: accept a set of <<Property>> and return the query results as a stream of `PropertyBox`, each containing the values of the properties of the set obtained from query execution
* `list(Iterable<P> properties)`: Same as above, but returning the results as a `List` instead of a `Stream`
* `findOne(Iterable<P> properties)` and `findOne(Property... properties)`: accept a set of <<Property>> and return the unique query result as an Optional `PropertyBox` containing the values of the properties of the set obtained from query execution

NOTE: Any concrete <<Datastore>> implementation could provide additional projections related to the specific Datastore persistence model.

[source, java]
.Query projection examples
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=projection,indent=0]
----
<1> Stream of values using `PROPERTY` as projection. The Stream type is the same of the property type (Integer)
<2> Optional unique value using `PROPERTY` as projection. The value type is the same of the property type (Integer)
<3> Stream of `PropertyBox` containing the values of the set of properties composed by `PROPERTY` and `ANOTHER_PROPERTY`
<4> List of `PropertyBox` containing the values of the set of properties composed by `PROPERTY` and `ANOTHER_PROPERTY`
<5> Optional unique `PropertyBox` containing the values of the set of properties composed by `PROPERTY` and `ANOTHER_PROPERTY`
<6> Unique value of the `sum` aggregation function applied to `PROPERTY`

*Bean projection:*

The link:{apidir}/com/holonplatform/core/query/BeanProjection.html[BeanProjection^] interface can be used to obtain the query results as *Java Bean* instances, providing the mapping bean class to be used. The query results are mapped to the bean class properties by matching the query selection `Path` names with the bean property names.

[source, java]
.Bean projection examples
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=beanprojection,indent=0]
----
<1> Stream of values using `MyBean` as projection, using all the bean property names as query selection
<2> Optional unique value using `MyBean` as projection, using all the bean property names as query selection
<3> Stream of values using `MyBean` as projection, using provided `CODE` and `TEXT` properties as query selection

==== Configuration

The link:{apidir}/com/holonplatform/core/datastore/DatastoreConfigProperties.html[DatastoreConfigProperties^] interface represents and provides the available configuration properties which can be used to configure a generic `Datastore`.

The interface extends a default `ConfigPropertySet` bound to the property name prefix *holon.datastore*.

The available configuration properties are listed below:

.Datastore configuration properties
|===
|Name |Type |Meaning

|_holon.datastore._ *trace*
|Boolean (`true` / `false`)
|Enable/disable Datastore operations tracing in log (for example, the concrete query definitions)
|===

The `DatastoreConfigProperties` can be loaded from a number of sources using the default `ConfigPropertySet` builder interface:

[source, java]
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleDatastore.java[tag=config,indent=0]
----
<1> Read the configuration properties from _default_ property sources (i.e. the `holon.properties` file)
<2> Read the configuration properties from `System` properties
<3> Read the configuration properties from a `Properties` instance
<4> Read the configuration properties from the `datastore.properties` file

===== Multiple Datastore configuration

When multiple `Datastore` configuration is required and properties are read from the same source, a _data context id_ can be used to discern one `Datastore` configuration property set form another.

From the property source point of view, the _data context id_ is used as a *suffix* after the configuration property set name (`holon.datastore`) and before the specific property name.

For example, let's say we have a configuration property set for two different datastores as follows:

[source, text]
----
holon.datastore.one.trace=true

holon.datastore.two.trace=false
----

In order to provide the configuration for two `Datastore` instances, one bound to the `one` configuration property set and the other bound to the `two` configuration property set, the `DatastoreConfigProperties` can be obtained as follows, specifying the _data context id_ when obtaining the builder:

[source, java]
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleDatastore.java[tag=config2,indent=0]
----

==== Common Datastore configuration properties

The link:{apidir}/com/holonplatform/core/datastore/DatastoreConfigProperties.html[DatastoreConfigProperties^] interface is a  `ConfigPropertySet` bound to the property name prefix *holon.datastore*, which provides common `Datastore` configuration properties:

|===
|Name |Type |Meaning

|_holon.datastore._ *trace*
|Boolean (true/false)
|Enable or disable Datastore operations tracing (for example, logging the concrete query/operations executed in native persistence store language).

|_holon.datastore._ *dialect*
|String
|The fully qualified class name of the _dialect_ to be used, if the concrete Datastore supports dialects.
|===

==== Relational Datastores

Regarding the _relational_ `Datastore` implementations, i.e. Datastores bound to a *RDBMS*, some additional components are provided to express typical _relational_ concepts concerning query definition and execution.

[[subquery]]
===== Sub-query

The link:{apidir}/com/holonplatform/core/datastore/relational/SubQuery.html[SubQuery^] interface can be used to represent a _sub-query_,  which can be used in a query definition to express query restrictions (filters) that involve a sub-query as filter operand.

To create a `SubQuery`, the `create(...)` static method of the link:{apidir}/com/holonplatform/core/datastore/relational/SubQuery.html[SubQuery^] interface can be used. The `SubQuery` definition process (target, restrictions, ordering and so on) is the same of a normal `Query` definition process, sharing the same query builder interface. In addition, a `SubQuery` must provide a `QueryProjection` to define the sub query selection type.

A `SubQuery` is a `QueryExpression`, allowing to use it as a `QueryFilter` operand.

IMPORTANT: When a `SubQuery` is used in a query, to avoid property/column names ambiguity, it is strongly recommended to provide a *parent* `DataTarget` for the query properties. The parent `DataTarget` of a `Property` can be setted using the `parent(...)` method of the property builder or directly using the `property(...)` methods provided by the link:{apidir}/com/holonplatform/core/datastore/DataTarget.html[DataTarget^] interface to create a `Property` with the given `DataTarget` as parent.

[source, java]
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=subquery1,indent=0]
----
<1> Create a `SubQuery`
<2> Use the `SubQuery` as the right operand of a `IN` query filter

Two convenience methods are provided by the `SubQuery` interface to create *EXISTS* and *NOT EXISTS* filter predicates. In this case, the sub-query selection projection is not required, and by default a `1` literal value will be used as selection.

[source, java]
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=subquery2,indent=0]
----
<1> A query with a filter using a *EXISTS* `SubQuery` predicate
<2> A query with a filter using a *NOT EXISTS* `SubQuery` predicate

[[joins]]
===== Alias and Joins

The link:{apidir}/com/holonplatform/core/datastore/relational/RelationalTarget.html[RelationalTarget^] interface can be used to express *alias* and *joins* for a `DataTarget`.

A `RelationalTarget` is a `DataTarget` itself, and provides methods to assign an *alias* name to the query target and to create *joins* with other targets.

[source, java]
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=alias,indent=0]
----
<1> Create a `RelationalTarget` using given `TARGET`
<2> Create a new `RelationalTarget` from the previous one, assigning an alias name to it

The following join types are supported:

* *INNER JOIN*: returns all rows when there is at least one match in BOTH tables represented by the source `DataTarget` and the joined `DataTarget`;
* *LEFT JOIN*: returns all rows from the left table (represented by the source `DataTarget`), and the matched rows from the right table (represented by the joined `DataTarget`);
* *RIGHT JOIN*: returns all rows from the right table (represented by the joined `DataTarget`), and the matched rows from the left table (represented by the source `DataTarget`);

IMPORTANT: Only one level of joins is supported, i.e. only the source `DataTarget` represented by the `RelationalTarget` can be joined with other targets, and no _sub_ join is supported.

The link:{apidir}/com/holonplatform/core/datastore/relational/Join.html[Join^] interface represents the join expression, supporting an *alias* name definition and a *ON* clause definition, to express any join restriction/filter predicate.

A `RelationalTarget` is created form a conventional `DataTarget` using the `of(DataTarget target)` static method.

IMPORTANT: When joins are used in a query, to avoid property/column names ambiguity, it is strongly recommended to provide a *parent* `DataTarget` for the query properties. The parent `DataTarget` of a `Property` can be setted using the `parent(...)` method of the property builder or directly using the `property(...)` methods provided by the link:{apidir}/com/holonplatform/core/datastore/DataTarget.html[DataTarget^] interface to create a `Property` with the given `DataTarget` as parent.

[source, java]
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=joins,indent=0]
----
<1> Create a `RelationalTarget` using `TARGET1`
<2> Join (using a *INNER* join type) the `TARGET1` with the `TARGET2`, using a *ON* clause to express the join condition
<3> Join (using a *INNER* join type) the `TARGET1` with the `TARGET2`, using a *ON* clause to express the join condition
<4> Join (using a *LEFT* join type) the `TARGET1` with the `TARGET2`, using a *ON* clause to express the join condition
<5> Join (using a *RIGHT* join type) the `TARGET1` with the `TARGET2`, using a *ON* clause to express the join condition
<6> Use the created `RelationalTarget` as a query target

[[DatastoreExtension]]
==== Datastore extension

Datastores provides two main entry points for extension purposes:

* `Datastore` components and operations extension through link:{apidir}/com/holonplatform/core/ExpressionResolver.html[ExpressionResolver^], which can be used to add custom expressions in order to extend or modify the data manipulation operations and query definition and execution strategies.

* Additional `Datastore` operations and functionalities relying on the link:{apidir}/com/holonplatform/core/datastore/DatastoreCommodity.html[DatastoreCommodity^] concept, through the registration of a link:{apidir}/com/holonplatform/core/datastore/DatastoreCommodityFactory.html[DatastoreCommodityFactory^].

===== Common `ExpressionResolver` s

For the most common query use cases, a set of builtin `ExpressionResolver` are made available to extend the main query clauses, providing custom clause representations to be translated into a standard query clause which the `Datastore` can handle.

An `ExpressionResolver` can be registered or unregistered in a `Datastore` implementation using the `addExpressionResolver(...)` and `removeExpressionResolver(...)` methods.

TIP: See concrete `Datastore` implementations documentation for additional information about any other `ExpressionResolver` based extension capabilities and resolvers registration options.

[[DataTargetResolver]]
===== DataTargetResolver

A link:{apidir}/com/holonplatform/core/datastore/DataTarget.DataTargetResolver.html[DataTargetResolver^] can be defined and registered in `Datastore` to _resolve_ a `DataTarget` unknown to the concrete Datastore implementation, by translating it into one which the Datastore can recognize and handle.

Tipically, a `DataTargetResolver` can be defined to resolve a `DataTarget` with a symbolic name into a specific Datastore data target.

[source, java]
.DataTargetResolver example
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleDatastore.java[tag=resolver,indent=0]
----
<1> Create a resolver which translates the symbolic `test` name in another named target with the `wellKnownTargetName` name
<2> Register the resolver in the Datastore

===== Custom QueryFilters

You can define and register custom `QueryFilter` implementations, to provide new predicates as a combination of simple standard predicates, possibly relying on parameters or application specific conditions, or to express specific filtering conditions related to a concrete persistence model to which a Datastore is bound.

A custom QueryFilter can be registered in a `Datastore` using standard <<ExpressionResolver>> interface.

A convenience link:{apidir}/com/holonplatform/core/query/QueryFilter.QueryFilterResolver.html[QueryFilterResolver^] interface is provided to facilitate the creation of a QueryFilter resolver.

A typical custom `QueryFilter` definition process takes place with the following steps:

. First af all, you have to define your custom filter representation, providing a class which implements the `QueryFilter` interface (and, optionally, an interface which extends `QueryFilter` and represents your custom filter API);
. Then create a class which implements `QueryFilterResolver`, generalized on your custom filter class/interface, whose purpose is to resolve the custom filter, transforming it into a `QueryFilter` that can be handled by the concrete `Datastore`. Two examples are: one of the builtin `QueryFilter` as described above, or a persistence model specific filter type recognized by a specific `Datastore` implementation.
. Finally, register the `QueryFilterResolver` in the `Datastore` instance, using the `addExpressionResolver(...)` method.

When the custom filter is defined and registered, it can be used anywhere in the _query_ or _bulk_ operations clauses obtained from the `Datastore` in which the resolver is registered.

[source, java]
.Custom QueryFilter example
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=custom,indent=0]
----
<1> Custom filter definition, implementing `QueryFilter`
<2> Custom filter resolver class
<3> The resolver translates a `MyFilter` into a predicate composed by well-known standard `QueryFilter`
<4> The resolver is registered in the `Datastore`, enabling the use of the `MyFilter` type filter in query and bulk operations clauses
<5> Use of a `MyFilter` in a query execution 

===== Custom QuerySorts

A custom `QuerySort` can be registered in a `Datastore` using standard <<ExpressionResolver>> interface.

A convenience link:{apidir}/com/holonplatform/core/query/QuerySort.QuerySortResolver.html[QuerySortResolver^] interface is provided to facilitate the creation of a QuerySort resolver.

A typical custom `QuerySort` definition process takes place with the following steps:

. First af all, you have to define your custom sort representation, providing a class wich implements the `QuerySort` interface (and, optionally, an interface which extends `QuerySort` and represents your custom filter API);
. Then create a class which implements `QuerySortResolver`, generalized on your custom sort class/interface, whose purpose is to resolve the custom sort, transforming it into a `QuerySort` declaration which the concrete `Datastore` can handle. For example, one of the builtin `QuerySort` as described above, or a persistence model specific sort type recognized by a specific `Datastore` implementation.
. Finally, register the `QuerySortResolver` in the `Datastore` instance, using the `addExpressionResolver(...)` method.

When the custom sort is defined and registered, it can be used anywhere in the _query_ clauses obtained from the `Datastore` in which the resolver is registered.

[source, java]
.Custom QuerySort example
----
include::{examplesdir}/com/holonplatform/core/examples/ExampleQuery.java[tag=customsort,indent=0]
----
<1> Custom sort definition, implementing `QuerySort`
<2> Custom sort resolver class
<3> The resolver translates a `MySort` into a sort composed by well-known standard `QuerySort`
<4> The resolver is registered in the `Datastore`, enabling the use of the `MySort` type sort in query clauses
<5> Use of a `MySort` in a query execution

===== Datastore _commodities_ definition and registration

Using the link:{apidir}/com/holonplatform/core/datastore/DatastoreCommodity.html[DatastoreCommodity^] representation, a `Datastore` can be extended by adding new operations and functionalities, represented by a class which implements the `DatastoreCommodity` interface.

A `DatastoreCommodity` must be provided using a link:{apidir}/com/holonplatform/core/datastore/DatastoreCommodityFactory.html[DatastoreCommodityFactory^] implementation, which has to be registered in the target `Datastore` through the `registerCommodity(DatastoreCommodityFactory<X, C> commodityFactory)` method.

Each commodity factory is bound to a specific `DatastoreCommodity` type, provided by the `getCommodityType()` factory method, and can use a `DatastoreCommodityContext` to create and configure the commodity instance when requested. Typically, each concrete Datastore implementation provides a specific `DatastoreCommodityContext` extension, to provide useful `Datastore` context and  configuration references.

A `DatastoreCommodity` can be obtained from `Datastore` using the `create(Class<C> commodityType)` method. A `DatastoreCommodityFactory` bound to the requested commodity type must be available, i.e. previuosly registered in `Datastore`, in order to obtain the commodity instance.

The `Query` object itself is a `DatastoreCommodity`, obtained by the convenience Datastore `query()` method. Each concrete Datastore implementation register a default factory to provide such commodity.

TIP: See concrete `Datastore` implementations documentation for additional information about any specific available _commodity_ types and registration options.

==== Available Datastores

By now, the holon platform provides two default `Datastore` implementations:

* link:../../holon-jdbc/overview.html[JDBC Datastore]: using the *Java Database Connectivity (JDBC)* specification to access a relational database
* link:../../holon-jpa/overview.html[JPA Datastore]: using the *Java Persistence API* specification to access a relational database
